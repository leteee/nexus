# Nexus Framework - Global Configuration
# =======================================================================
# This file contains framework-wide defaults and plugin configurations.
# It serves as the foundation for all cases and can be overridden by:
# 1. Case OR Template configurations (mutual exclusion, not both)
# 2. CLI arguments (--config key=value)
#
# Configuration Hierarchy (4 layers, highest to lowest precedence):
#   1. CLI overrides (--config key=value)
#   2. Case OR Template config (mutual exclusion)
#   3. Global config (this file)
#   4. Plugin defaults (from PluginConfig classes)
#
# Template Semantics:
#   - Templates are NOT a configuration layer to merge
#   - Templates are starting points/scaffolds that REPLACE case.yaml when specified
#   - Use --template to run with template (case.yaml ignored)
#   - Use without --template to run with case.yaml
# =======================================================================

framework:
  name: "nexus"
  version: "1.0.0"
  cases_root: "cases"  # Cases root directory (relative or absolute path)

  # Logging configuration
  logging:
    level: INFO  # DEBUG, INFO, WARNING, ERROR
    format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

  # Performance and caching
  performance:
    default_cache_size: 100  # MB
    lazy_loading: true
    max_concurrent_plugins: 4

# Plugin Discovery Configuration
# Nexus will scan these locations for plugins
plugins:
  # Module paths to scan (Python module names)
  modules: []
  # Example:
  # modules:
  #   - "my_custom_plugins"
  #   - "company.data_plugins"

  # Directory paths to scan (relative to project root or absolute)
  paths: []
  # Example:
  # paths:
  #   - "custom_plugins"           # Relative to project root
  #   - "/opt/shared/nexus_plugins" # Absolute path
  #   - "~/my_plugins"             # Home directory

# Handler Discovery Configuration
# Handlers manage different file formats (CSV, JSON, Parquet, etc.)
handlers:
  # Additional handler paths
  paths: []
  # Example:
  # paths:
  #   - "custom_handlers"
  #   - "/opt/shared/handlers"

# Global Plugin Defaults
# These provide fallback defaults when not specified elsewhere
# IMPORTANT: Configure plugin behavior in templates/cases for actual use
plugin_defaults:
  # Data Generation Plugins
  "Data Generator":
    num_rows: 1000        # Number of rows to generate
    random_seed: 42       # For reproducible results
    num_categories: 3     # Number of categories in categorical columns
    noise_level: 0.1      # Amount of noise to add (0.0 to 1.0)

  "Sample Data Generator":
    dataset_type: "customers"  # customers, sales, products, etc.
    size: "medium"            # small, medium, large

  # Data Cleaning Plugins
  "Data Cleaner":
    remove_outliers: true        # Remove statistical outliers
    outlier_threshold: 2.0       # Z-score threshold for outliers
    fill_missing: true           # Fill missing values
    missing_strategy: "median"   # mean, median, mode, forward_fill

  # Data Validation Plugins
  "Data Validator":
    max_null_percentage: 0.05    # Maximum allowed null percentage (5%)
    min_rows: 100               # Minimum required rows

  "Data Quality Checker":
    check_duplicates: true       # Check for duplicate rows
    check_data_types: true       # Validate data types
    check_outliers: false        # Check for outliers (separate from cleaner)
    check_consistency: true      # Check data consistency
    outlier_threshold: 3.0       # Different threshold than cleaner

  # Data Transformation Plugins
  "Data Transformer":
    normalize_columns: []        # Columns to normalize (set in templates)
    create_derived_features: false  # Create additional features
    transformation_methods: ["standard"]  # standard, minmax, robust

  "Data Aggregator":
    group_by_column: "category"  # Default grouping column
    aggregation_method: "mean"   # mean, sum, count, min, max

# Environment-specific Overrides
# Use these for development vs production differences
environments:
  development:
    framework:
      logging:
        level: DEBUG
    plugin_defaults:
      "Data Generator":
        num_rows: 100      # Smaller datasets for faster dev cycles
      "Data Quality Checker":
        check_outliers: false  # Skip expensive checks in dev

  testing:
    framework:
      logging:
        level: ERROR       # Minimal logging during tests
    plugin_defaults:
      "Data Generator":
        num_rows: 50       # Tiny datasets for unit tests
        random_seed: 999   # Different seed for test isolation

  production:
    framework:
      logging:
        level: WARNING
      performance:
        default_cache_size: 500  # More memory available
        max_concurrent_plugins: 8
    plugin_defaults:
      "Data Generator":
        num_rows: 10000    # Larger datasets in production
      "Data Quality Checker":
        check_duplicates: true
        check_data_types: true
        check_outliers: true
        check_consistency: true

# ========================================================================
# Configuration Best Practices
# ========================================================================
#
# 1. Plugin I/O Configuration:
#    - All I/O paths are declared in plugin config classes with DataSource/DataSink annotations
#    - Users override I/O paths in YAML config alongside behavior parameters
#    - No separate data_sources or outputs sections needed in most cases
#
#    Example plugin config:
#      class MyPluginConfig(PluginConfig):
#          input_data: Annotated[str, DataSource(handler="csv")] = "data/input.csv"
#          output_data: Annotated[str, DataSink(handler="csv")] = "data/output.csv"
#          threshold: float = 0.5
#
#    Example YAML usage:
#      pipeline:
#        - plugin: "My Plugin"
#          config:
#            input_data: "custom/path/input.csv"   # Override I/O path
#            output_data: "custom/path/output.csv" # Override I/O path
#            threshold: 0.8                        # Override behavior param
#
# 2. Global data_sources (Optional):
#    - Only use for shared external data sources accessed by multiple plugins
#    - Reference with special syntax: "source:name"
#    - Most pipelines don't need this
#
#    Example (advanced use case):
#      data_sources:
#        customer_master:
#          handler: csv
#          path: "/shared/customers.csv"
#          read_only: true
#
#      pipeline:
#        - plugin: "Enricher"
#          config:
#            customer_data: "source:customer_master"  # Reference global source
#            output_data: "data/enriched.csv"
#
# 3. Configuration Hierarchy (4 layers):
#    CLI overrides > Case/Template config > Global config > Plugin defaults
#
#    Note: Case and Template are mutually exclusive (not merged):
#    - With --template: Use template, ignore case.yaml
#    - Without --template: Use case.yaml
#
# 4. Where to configure plugins:
#    - Global config: Organization-wide defaults only
#    - Templates: Reusable pipeline patterns (RECOMMENDED)
#    - Case configs: Case-specific customizations
#    - CLI: Quick experimentation and overrides
# ========================================================================
