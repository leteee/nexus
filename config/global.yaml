# Nexus Framework - Global Configuration
# =======================================================================
# This file contains framework-wide defaults and plugin configurations.
# It serves as the foundation for all cases and can be overridden by:
# 1. Case OR Template configurations (mutual exclusion, not both)
# 2. CLI arguments (--config key=value)
#
# Configuration Hierarchy (4 layers, highest to lowest precedence):
#   1. CLI overrides (--config key=value)
#   2. Case OR Template config (mutual exclusion)
#   3. Global config (this file)
#   4. Plugin defaults (from PluginConfig classes)
#
# Template Semantics:
#   - Templates are NOT a configuration layer to merge
#   - Templates are starting points/scaffolds that REPLACE case.yaml when specified
#   - Use --template to run with template (case.yaml ignored)
#   - Use without --template to run with case.yaml
# =======================================================================

framework:
  name: "nexus"
  version: "1.0.0"
  cases_root: "cases"  # Cases root directory (relative or absolute path)

  # Logging configuration
  logging:
    level: INFO  # DEBUG, INFO, WARNING, ERROR
    format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

  # Performance and caching
  performance:
    default_cache_size: 100  # MB
    lazy_loading: true
    max_concurrent_plugins: 4

  # Discovery Configuration
  # Controls how Nexus discovers plugins, handlers, and templates
  discovery:
    # Plugin Discovery
    plugins:
      # Python module names to scan for @plugin decorators
      modules: []
      # Example:
      # modules:
      #   - "my_custom_plugins"
      #   - "company.data_plugins"

      # Directory paths to scan (relative to project root or absolute)
      paths: []
      # Example:
      # paths:
      #   - "custom_plugins"           # Relative to project root
      #   - "/opt/shared/nexus_plugins" # Absolute path
      #   - "~/my_plugins"             # Home directory

      # Whether to scan subdirectories recursively
      recursive: true

    # Handler Discovery
    handlers:
      # Directory paths to scan for DataHandler implementations
      paths: []
      # Example:
      # paths:
      #   - "custom_handlers"
      #   - "/opt/shared/handlers"

      # Whether to scan subdirectories recursively
      recursive: true

    # Template Discovery
    templates:
      # Directories to search for templates (in priority order)
      # First match wins when multiple templates have the same name
      paths:
        - "templates"  # Built-in templates (default, highest priority)

      # Example: Add custom template directories
      # paths:
      #   - "templates"                  # Built-in (highest priority)
      #   - "custom_templates"           # Project-specific
      #   - "~/shared/nexus_templates"   # User's shared templates
      #   - "/opt/company/templates"     # Company-wide templates
      #   - "$NEXUS_TEMPLATES"           # Environment variable

      # Search subdirectories for nested organization
      # false: Only top-level *.yaml files (flat structure)
      # true: All *.yaml in subdirectories (templates/custom/pipeline.yaml â†’ "custom/pipeline")
      recursive: false

# Global Plugin Configuration
# Provides fallback defaults for all plugins when not specified elsewhere
# IMPORTANT: Configure plugin behavior in templates/cases for actual use
plugins:
  # Data Generation Plugins
  "Data Generator":
    num_rows: 1000        # Number of rows to generate
    random_seed: 42       # For reproducible results
    num_categories: 3     # Number of categories in categorical columns
    noise_level: 0.1      # Amount of noise to add (0.0 to 1.0)

  "Sample Data Generator":
    dataset_type: "customers"  # customers, sales, products, etc.
    size: "medium"            # small, medium, large

  # Data Validation Plugins
  "Data Validator":
    check_nulls: true           # Check for null values
    check_duplicates: true      # Check for duplicate rows
    check_types: true           # Check data types
    required_columns: []        # List of required columns

  # Data Filter Plugin
  "Data Filter":
    column: "value"             # Column to filter on
    operator: ">"               # >, <, >=, <=, ==, !=
    threshold: 0.0              # Threshold value
    remove_nulls: true          # Remove null values before filtering

  # Data Aggregator Plugin
  "Data Aggregator":
    group_by: "category"        # Column to group by
    agg_column: "value"         # Column to aggregate
    agg_function: "mean"        # mean, sum, count, min, max, std

# Environment-specific Overrides
# Use these for development vs production differences
environments:
  development:
    framework:
      logging:
        level: DEBUG
    plugins:
      "Data Generator":
        num_rows: 100      # Smaller datasets for faster dev cycles

  testing:
    framework:
      logging:
        level: ERROR       # Minimal logging during tests
    plugins:
      "Data Generator":
        num_rows: 50       # Tiny datasets for unit tests
        random_seed: 999   # Different seed for test isolation

  production:
    framework:
      logging:
        level: WARNING
      performance:
        default_cache_size: 500  # More memory available
        max_concurrent_plugins: 8
    plugins:
      "Data Generator":
        num_rows: 10000    # Larger datasets in production

# ========================================================================
# Configuration Best Practices
# ========================================================================
#
# 1. Plugin I/O Configuration:
#    - All I/O paths are declared in plugin config classes with DataSource/DataSink annotations
#    - Users override I/O paths in YAML config alongside behavior parameters
#    - No separate data_sources or outputs sections needed in most cases
#
#    Example plugin config:
#      class MyPluginConfig(PluginConfig):
#          input_data: Annotated[str, DataSource(handler="csv")] = "data/input.csv"
#          output_data: Annotated[str, DataSink(handler="csv")] = "data/output.csv"
#          threshold: float = 0.5
#
#    Example YAML usage:
#      pipeline:
#        - plugin: "My Plugin"
#          config:
#            input_data: "custom/path/input.csv"   # Override I/O path
#            output_data: "custom/path/output.csv" # Override I/O path
#            threshold: 0.8                        # Override behavior param
#
# 2. Global data_sources (Optional):
#    - Only use for shared external data sources accessed by multiple plugins
#    - Reference with special syntax: "source:name"
#    - Most pipelines don't need this
#
#    Example (advanced use case):
#      data_sources:
#        customer_master:
#          handler: csv
#          path: "/shared/customers.csv"
#          read_only: true
#
#      pipeline:
#        - plugin: "Enricher"
#          config:
#            customer_data: "source:customer_master"  # Reference global source
#            output_data: "data/enriched.csv"
#
# 3. Configuration Hierarchy (4 layers):
#    CLI overrides > Case/Template config > Global config > Plugin defaults
#
#    Note: Case and Template are mutually exclusive (not merged):
#    - With --template: Use template, ignore case.yaml
#    - Without --template: Use case.yaml
#
# 4. Where to configure plugins:
#    - Global config (plugins.*): Organization-wide defaults only
#    - Templates: Reusable pipeline patterns (RECOMMENDED)
#    - Case configs: Case-specific customizations
#    - CLI: Quick experimentation and overrides
#
# 5. Configuration Namespaces:
#    - framework.*: Framework settings (logging, performance, discovery)
#    - data_sources.*: Global/shared data sources (optional, for cross-pipeline use)
#    - plugins.*: Plugin behavior defaults
#    - pipeline: Pipeline definition (in templates/cases only)
#    - meta: Metadata (name, description, in templates/cases only)
# ========================================================================
